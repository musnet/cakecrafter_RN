// src/services/ApiService.js - Communication #63.1: Enhanced with Environment Integration
// üåê ENHANCED: Added environment-aware API configuration with development/production switching
// ü§ñ NEW: Complete AI generation methods integration with Django backend
// üõ°Ô∏è PRESERVED: ALL existing functionality maintained exactly as-is
// ‚ú® FEATURES: Environment switching, AI generation, enhanced error handling
// üîß BACKWARD COMPATIBLE: All existing code continues to work unchanged

// ============================================================================
// ENVIRONMENT INTEGRATION - Communication #63.1
// ============================================================================
import { Environment, EnvironmentUtils } from '../config/environment';
import { apiConfig, API_ENDPOINTS } from '../config/api.config';

// ============================================================================
// DYNAMIC API CONFIGURATION - Communication #63.1
// ============================================================================
// Environment-aware API URLs (replaces hardcoded URLs)
const API_BASE_URL = Environment.api.baseUrl;
const IMAGES_BASE_URL = Environment.isProduction 
  ? 'https://cakecrafterapi.ebita.ai/media/generated_images/'
  : 'http://127.0.0.1:8000/media/generated_images/';

// ============================================================================
// PRESERVED: CATEGORY CACHE MANAGEMENT - Communication #60.16
// ============================================================================
const categoryCache = new Map();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

export class ApiService {
  
  // ============================================================================
  // NEW: AI GENERATION METHODS - Communication #63.1
  // ============================================================================
  
  /**
   * Generate cake using AI
   * Integrates with Django backend AI generation endpoints
   */
  static async generateCake(prompt, provider = 'auto', options = {}) {
    try {
      EnvironmentUtils.debugLog('ü§ñ Starting AI cake generation', {
        prompt: prompt.substring(0, 50) + '...',
        provider,
        environment: Environment.environment
      });
      
      const requestBody = {
        prompt,
        provider,
        user_id: options.userId || 1000,
        style: options.style || 'elegant',
        occasion: options.occasion || 'general',
        ...options
      };
      
      const response = await apiConfig.generateCake(prompt, provider, options);
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`AI Generation failed: ${response.status} - ${errorText}`);
      }
      
      const data = await response.json();
      
      EnvironmentUtils.debugLog('‚úÖ AI generation initiated successfully', {
        generation_id: data.generation_id,
        provider_used: data.provider_used
      });
      
      return data;
      
    } catch (error) {
      EnvironmentUtils.logApiError('ai-generate', error, 'generateCake');
      
      // Fallback for development/testing
      if (Environment.isDevelopment) {
        console.warn('üîÑ Using fallback generation for development');
        return this.getMockAIGeneration(prompt, provider);
      }
      
      throw error;
    }
  }
  
  /**
   * Enhance prompt using AI
   */
  static async enhancePrompt(prompt, style = 'elegant', occasion = 'general') {
    try {
      EnvironmentUtils.debugLog('‚ú® Enhancing prompt', { prompt, style, occasion });
      
      const response = await apiConfig.enhancePrompt(prompt, style, occasion);
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Prompt enhancement failed: ${response.status} - ${errorText}`);
      }
      
      const data = await response.json();
      
      EnvironmentUtils.debugLog('‚úÖ Prompt enhanced successfully');
      
      return data;
      
    } catch (error) {
      EnvironmentUtils.logApiError('enhance-prompt', error, 'enhancePrompt');
      
      // Fallback enhancement
      return {
        success: true,
        enhanced_prompt: `${prompt}, professional food photography, elegant presentation, high-end bakery quality`,
        original_prompt: prompt,
        enhancement_type: 'fallback'
      };
    }
  }
  
  /**
   * Get available AI providers
   */
  static async getAIProviders() {
    try {
      EnvironmentUtils.debugLog('üîå Fetching AI providers');
      
      const response = await apiConfig.getAIProviders();
      
      if (!response.ok) {
        throw new Error(`Failed to fetch providers: ${response.status}`);
      }
      
      const data = await response.json();
      
      EnvironmentUtils.debugLog('‚úÖ AI providers loaded', {
        count: data.providers?.length || 0
      });
      
      return data;
      
    } catch (error) {
      EnvironmentUtils.logApiError('providers', error, 'getAIProviders');
      
      // Return mock providers for fallback
      return {
        success: true,
        providers: this.getMockAIProviders()
      };
    }
  }
  
  /**
   * Get generation status
   */
  static async getGenerationStatus(generationId) {
    try {
      const response = await apiConfig.getGenerationStatus(generationId);
      
      if (!response.ok) {
        throw new Error(`Status check failed: ${response.status}`);
      }
      
      const data = await response.json();
      return data;
      
    } catch (error) {
      EnvironmentUtils.logApiError('generation-status', error, 'getGenerationStatus');
      throw error;
    }
  }
  
  /**
   * Poll generation status until completion
   */
  static async pollGenerationStatus(generationId, onProgress = null, maxAttempts = 30) {
    return apiConfig.pollGenerationStatus(generationId, onProgress, maxAttempts);
  }
  
  /**
   * Get user's generation history
   */
  static async getGenerationHistory(userId = 1000, limit = 20) {
    try {
      EnvironmentUtils.debugLog('üìú Fetching generation history', { userId, limit });
      
      const endpoint = `${API_ENDPOINTS.AI.USER_GENERATIONS(userId)}&limit=${limit}`;
      const response = await apiConfig.makeRequest(endpoint, { method: 'GET' });
      
      if (!response.ok) {
        throw new Error(`History fetch failed: ${response.status}`);
      }
      
      const data = await response.json();
      return data;
      
    } catch (error) {
      EnvironmentUtils.logApiError('generation-history', error, 'getGenerationHistory');
      return { results: [] };
    }
  }
  
  // ============================================================================
  // PRESERVED: EXISTING CATEGORY FILTERING METHODS - Communication #60.16
  // ============================================================================
  
  /**
   * Get cakes by category with caching and filtering support
   * ‚úÖ PRESERVED: Original method unchanged, enhanced with environment logging
   */
  static async getCakesByCategory(categoryKey, options = {}) {
    try {
      const { limit = 20, page = 1, clearPrevious = true, forceRefresh = false } = options;
      
      EnvironmentUtils.debugLog(`üéØ Fetching cakes for category: ${categoryKey}`, {
        environment: Environment.environment
      });
      
      if (clearPrevious) {
        this.clearCategoryCache();
        EnvironmentUtils.debugLog(`üßπ Cleared previous category cache`);
      }
      
      const cacheKey = `${categoryKey}_${page}_${limit}`;
      const cachedData = categoryCache.get(cacheKey);
      
      if (!forceRefresh && cachedData && (Date.now() - cachedData.timestamp) < CACHE_DURATION) {
        EnvironmentUtils.debugLog(`üíæ Returning cached data for: ${categoryKey}`);
        return cachedData.data;
      }
      
      // Use environment-aware URL
      const url = `${API_BASE_URL}/cakes/?category=${encodeURIComponent(categoryKey)}&limit=${limit}&offset=${(page - 1) * limit}`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: apiConfig.getHeaders()
      });
      
      if (!response.ok) {
        throw new Error(`Category API request failed: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      
      categoryCache.set(cacheKey, { data: data, timestamp: Date.now(), category: categoryKey });
      
      EnvironmentUtils.debugLog(`‚úÖ Loaded ${data.results?.length || 0} cakes for category: ${categoryKey}`);
      return data;
      
    } catch (error) {
      EnvironmentUtils.logApiError(`category-${categoryKey}`, error, 'getCakesByCategory');
      
      return {
        results: this.getMockCakesByCategory(categoryKey),
        count: this.getMockCakesByCategory(categoryKey).length,
        next: null,
        previous: null
      };
    }
  }
  
  /**
   * Clear category cache (used when switching categories)
   * ‚úÖ PRESERVED: Original method unchanged
   */
  static clearCategoryCache() {
    const cacheSize = categoryCache.size;
    categoryCache.clear();
    EnvironmentUtils.debugLog(`üßπ Cleared category cache (${cacheSize} entries)`);
  }
  
  /**
   * Get mock cakes filtered by category for fallback
   * ‚úÖ PRESERVED: Original method unchanged
   */
  static getMockCakesByCategory(categoryKey) {
    const allMockCakes = this.getMockCakes();
    
    // Filter by category or return all if no match
    const filteredCakes = allMockCakes.filter(cake => 
      cake.category.toLowerCase() === categoryKey.toLowerCase()
    );
    
    // If no cakes for category, return a few generic ones
    if (filteredCakes.length === 0) {
      return allMockCakes.slice(0, 3).map(cake => ({
        ...cake,
        category: categoryKey,
        name: `${categoryKey.charAt(0).toUpperCase() + categoryKey.slice(1)} ${cake.name}`
      }));
    }
    
    return filteredCakes;
  }
  
  /**
   * Refresh category data (force fetch from API)
   * ‚úÖ PRESERVED: Original method unchanged
   */
  static async refreshCategoryData(categoryKey, options = {}) {
    EnvironmentUtils.debugLog(`üîÑ Force refreshing category: ${categoryKey}`);
    return this.getCakesByCategory(categoryKey, { ...options, forceRefresh: true });
  }

  // ============================================================================
  // PRESERVED: ALL EXISTING METHODS - Communication #60.16
  // ============================================================================
  
  /**
   * Check database and backend health
   * ‚úÖ PRESERVED: Enhanced with environment awareness
   */
  static async checkDatabaseHealth() {
    try {
      EnvironmentUtils.debugLog('üè• Checking database health', {
        environment: Environment.environment,
        apiUrl: API_BASE_URL
      });
      
      const response = await fetch(`${API_BASE_URL}/health/`, {
        method: 'GET',
        headers: apiConfig.getHeaders(),
        timeout: Environment.api.timeout,
      });
      
      if (!response.ok) {
        throw new Error(`Health check failed: ${response.status} ${response.statusText}`);
      }
      
      const healthData = await response.json();
      
      EnvironmentUtils.debugLog('‚úÖ Health check successful', healthData);
      
      // Return standardized health status
      return {
        connected: true,
        status: healthData.status || 'healthy',
        service: healthData.service || 'CakeCrafter.AI Backend',
        apiVersion: healthData.api_version || '1.0.0',
        environment: healthData.environment || Environment.environment,
        components: healthData.components || {},
        timestamp: healthData.timestamp || new Date().toISOString(),
        responseTime: Date.now(),
        apiUrl: API_BASE_URL, // Include current API URL
      };
      
    } catch (error) {
      EnvironmentUtils.logApiError('health', error, 'checkDatabaseHealth');
      
      // Return error status
      return {
        connected: false,
        status: 'error',
        error: error.message,
        service: 'CakeCrafter.AI Backend',
        environment: Environment.environment,
        apiUrl: API_BASE_URL,
        timestamp: new Date().toISOString(),
      };
    }
  }
  
  /**
   * Get cakes from production API with pagination support
   * ‚úÖ PRESERVED: Enhanced with environment awareness
   */
  static async getCakes(params = {}) {
    try {
      const { limit = 20, page = 1 } = params;
      const url = `${API_BASE_URL}/cakes/?limit=${limit}&offset=${(page - 1) * limit}`;
      
      EnvironmentUtils.logApiRequest('GET', url);
      
      const response = await fetch(url, {
        headers: apiConfig.getHeaders()
      });
      
      const data = await response.json();
      
      EnvironmentUtils.debugLog('üç∞ Loaded cakes from API', {
        count: data.results?.length || 0,
        environment: Environment.environment
      });
      
      return data;
    } catch (error) {
      EnvironmentUtils.logApiError('cakes', error, 'getCakes');
      return { results: this.getMockCakes() };
    }
  }

  /**
   * Get categories from production API
   * ‚úÖ PRESERVED: Enhanced with environment awareness
   */
  static async getCategories() {
    try {
      const url = `${API_BASE_URL}/categories/`;
      
      EnvironmentUtils.logApiRequest('GET', url);
      
      const response = await fetch(url, {
        headers: apiConfig.getHeaders()
      });
      
      const data = await response.json();
      
      EnvironmentUtils.debugLog('üìÇ Loaded categories', {
        count: data?.length || 0,
        environment: Environment.environment
      });
      
      return data;
    } catch (error) {
      EnvironmentUtils.logApiError('categories', error, 'getCategories');
      return this.getMockCategories();
    }
  }

  /**
   * Search cakes
   * ‚úÖ PRESERVED: Enhanced with environment awareness
   */
  static async searchCakes(query, params = {}) {
    try {
      const { limit = 20 } = params;
      const url = `${API_BASE_URL}/cakes/search/?q=${encodeURIComponent(query)}&limit=${limit}`;
      
      EnvironmentUtils.logApiRequest('GET', url, { query });
      
      const response = await fetch(url, {
        headers: apiConfig.getHeaders()
      });
      
      const data = await response.json();
      
      EnvironmentUtils.debugLog('üîç Search completed', {
        query,
        results: data.results?.length || 0
      });
      
      return data;
    } catch (error) {
      EnvironmentUtils.logApiError('search', error, 'searchCakes');
      return { results: [] };
    }
  }

  /**
   * Mock cake data for fallback
   * ‚úÖ PRESERVED: Original method unchanged
   */
  static getMockCakes() {
    return [
      {
        id: 1,
        name: 'Luxury Birthday Cake',
        price: 'QAR 250',
        image: `${IMAGES_BASE_URL}Cake_imaes199993 (1).jpg`,
        rating: 4.9,
        description: 'Exquisite birthday celebration cake',
        category: 'birthday'
      },
      {
        id: 2,
        name: 'Wedding Masterpiece',
        price: 'QAR 800',
        image: `${IMAGES_BASE_URL}Cake_imaes199993 (5).jpg`,
        rating: 5.0,
        description: 'Elegant multi-tier wedding cake',
        category: 'wedding'
      },
      {
        id: 3,
        name: 'Corporate Event Cake',
        price: 'QAR 400',
        image: `${IMAGES_BASE_URL}Cake_imaes199993 (12).jpg`,
        rating: 4.8,
        description: 'Professional corporate celebration cake',
        category: 'corporate'
      },
      {
        id: 4,
        name: 'Custom Design Cake',
        price: 'QAR 350',
        image: `${IMAGES_BASE_URL}Cake_imaes199993 (18).jpg`,
        rating: 4.9,
        description: 'Personalized custom design cake',
        category: 'custom'
      }
    ];
  }

  /**
   * Mock categories for fallback
   * ‚úÖ PRESERVED: Original method unchanged
   */
  static getMockCategories() {
    return [
      {
        id: 1,
        name: 'Birthday',
        nameAr: 'ÿπŸäÿØ ŸÖŸäŸÑÿßÿØ',
        count: 25,
        color: '#FF6B6B',
        image: `${IMAGES_BASE_URL}Cake_imaes199993 (1).jpg`
      },
      {
        id: 2,
        name: 'Wedding',
        nameAr: 'ÿ≤ŸÅÿßŸÅ',
        count: 18,
        color: '#4ECDC4',
        image: `${IMAGES_BASE_URL}Cake_imaes199993 (5).jpg`
      },
      {
        id: 3,
        name: 'Corporate',
        nameAr: 'ÿ¥ÿ±ŸÉÿßÿ™',
        count: 12,
        color: '#45B7D1',
        image: `${IMAGES_BASE_URL}Cake_imaes199993 (12).jpg`
      },
      {
        id: 4,
        name: 'Custom',
        nameAr: 'ŸÖÿÆÿµÿµ',
        count: 30,
        color: '#96CEB4',
        image: `${IMAGES_BASE_URL}Cake_imaes199993 (18).jpg`
      }
    ];
  }
  
  // ============================================================================
  // NEW: AI MOCK DATA FOR DEVELOPMENT - Communication #63.1
  // ============================================================================
  
  /**
   * Mock AI providers for fallback
   */
  static getMockAIProviders() {
    return [
      {
        id: 'openai',
        name: 'OpenAI DALL-E 3',
        description: 'Premium AI with highest quality results',
        status: 'available',
        cost_per_image: '0.040',
        estimated_time: '30-60 seconds'
      },
      {
        id: 'huggingface_free',
        name: 'Hugging Face (FREE)',
        description: 'Free AI generation with good quality',
        status: 'available',
        cost_per_image: '0.000',
        estimated_time: '60-120 seconds'
      },
      {
        id: 's3_mock_real',
        name: 'S3 Real Cakes (Fallback)',
        description: 'Real cake images from S3 bucket',
        status: 'available',
        cost_per_image: '0.000',
        estimated_time: 'instant'
      }
    ];
  }
  
  /**
   * Mock AI generation for development/fallback
   */
  static getMockAIGeneration(prompt, provider) {
    const generationId = `mock-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    return {
      success: true,
      generation_id: generationId,
      status: 'completed',
      image_url: `${IMAGES_BASE_URL}Cake_imaes199993 (${Math.floor(Math.random() * 20) + 1}).jpg`,
      provider_used: provider || 'mock',
      cost_qar: '0.000',
      estimated_time: 'instant',
      prompt_used: prompt,
      s3_url: `s3://mock-bucket/ai_generated/aigenerated${generationId}.jpg`,
      timestamp: new Date().toISOString()
    };
  }
}

// ============================================================================
// ENVIRONMENT-AWARE CONSTANTS - Communication #63.1
// ============================================================================

// Export environment-aware URLs (backward compatible)
export { API_BASE_URL, IMAGES_BASE_URL };

// Export environment info for debugging
export const ENVIRONMENT_INFO = {
  current: Environment.environment,
  apiUrl: API_BASE_URL,
  imagesUrl: IMAGES_BASE_URL,
  debugEnabled: Environment.features.debugLogging,
  timestamp: new Date().toISOString()
};

// ============================================================================
// INITIALIZATION LOG - Communication #63.1
// ============================================================================

if (Environment.features.debugLogging) {
  console.log('üöÄ Communication #63.1 - Enhanced ApiService Loaded:', ENVIRONMENT_INFO);
}